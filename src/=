// Coverage for the project
/// <reference path="../node_modules/typescript/lib/lib.es6.d.ts" />
import Immutable = require('immutable');
import Reflect   = require("harmony-reflect");

import Infer     = require("./infer")
import Tracking  = require("./tracking");

// types ----------
export type Name = string;
type Key = string;

// export enum Type {
//     Integer,
//     String,
//     Boolean,
//     Object,
//     Undefined,
//     FunctionRef,
//     FunctionLit
// }

enum Action {
    Set,
    Get,
    Apply
}

export type Type
    = BuiltinType
    | ObjectType

interface ObjectType {
    type: 'object',
    properties: Immutable.Map<String, Property>

    call?: Call
}

interface Property {
    type: Type
}

export interface BuiltinType {
    type: "number" | "string" | "boolean" | "void" | "any",
    action: Action
}

export interface Call {
    parameters: Immutable.List<Parameter>,
    returnType: TypeObject
}

interface Parameter {
    name: string,
    type: TypeObject
}

export type ObjectMap = Immutable.Map<Name, ObjectType>;
export type ObjectType = Immutable.Map<Key, Immutable.List<TypeObject>>;
type TimeoutID = number;


// code ----------
var DEBUG = false;
var output = true

export var object_map: ObjectMap = <ObjectMap>Immutable.Map({})
var timeoutID: TimeoutID;

export function RESET() {
    object_map = <ObjectMap>Immutable.Map({})
}
export function outputTypes(val: boolean) {
    output = val
}

function touch(root_key: string): void {
    if (timeoutID) {
        clearTimeout(timeoutID);
    }
    timeoutID = setTimeout(function() {
        if (output) {
            const tmp = JSON.stringify(Infer.types(object_map, root_key));
            console.error(tmp)
        }
    }, 50)
}

// name might have to be allowed to be undefined.
export function wrap(value: any, name: string, root?: string): any {
    var root_key = root || name;

    switch(simple_type(value)) {
    case Type.Object:
        return wrap_obj(value, name, root_key)
    case Type.FunctionRef:
        return wrap_fun(value, name, root_key)
    default:
        console.log('Skipping: ' + name);
        return value
    }
}

function wrap_fun(value: TypeObject, name: string, root_key?: string): any {
    function updateType(key: string, value: any): ObjectType {
        let me = object_map.get(name, <ObjectType> Immutable.Map())
        var res_type = me.get(key, Immutable.List<TypeObject>())
        let new_type: TypeObject = value
        res_type = res_type.push(new_type)
        me = me.set(key, res_type)
        return me
    }

    return new Proxy(value, {
        get: function(target: any, attr: string, __: any): any {
            if (name === "toJSON") {
                return function() {
                    return target
                }
            } else {
                var res = Reflect.get(target, attr)
                return res
            }
        },
        // refine this return type?
        set: function(target: any, attr: string, val: any, receiver: any): any {
            Reflect.set(target, attr, val)
        },
        apply: function(target: any, thisValue: any, args: any[]): any {
            const arg_types = args.map(function(arg) {
                return get_type(arg, Action.Get)
            })
            const ret = Reflect.apply(target, thisValue, args)

            const ret_type = get_type(ret, Action.Get)
            console.log(name)
            const me = updateType(name, {
                action: Action.Apply,
                type: Type.FunctionLit, // TODO: not a boolean
                args: arg_types,
                ret: ret_type
            })
            object_map = object_map.set(name, me)
            return wrap(ret, name + '.' + 'ret', root_key)
        }
    })
}

function wrap_obj(value: any, name: string, root_key?: string): any {

    function updateType(key: string, value: any, action: Action): ObjectType {
        let me = object_map.get(name, <ObjectType> Immutable.Map())
        var res_type = me.get(key, Immutable.List<TypeObject>())
        let new_type: TypeObject = get_type(value, action)
        res_type = res_type.push(new_type)
        me = me.set(key, res_type)
        return me
    }

    return new Proxy(value, {
        get: function(target: any, key: string, receiver: any): any {
            var res = Reflect.get(target,key);

            if (typeof key === "symbol") {
                res = target
            }

            let me = updateType(key, res, Action.Get)
            object_map = object_map.set(name, me)

            touch(root_key)
            return wrap(res, name + '.' + key.toString(), root_key);
        },
        set: function(target: any, key: string, value: any, receiver: any): any {

            let me = updateType(key, value, Action.Set)
            object_map = object_map.set(name, me)

            // set value to thing.
            Reflect.set(target, key, value)

            // return value
            touch(root_key)
            return value
        }
    })
}

function get_type(value: any, action: Action): TypeObject {
    switch (simple_type(value)) {
    case Type.FunctionRef:
        return {
            type: Type.FunctionRef,
            action: action,
            parameters: [],
            returnType: { type: Type.Undefined, action: action}
        }
    default:
        return {
            type: simple_type(value),
            action: action
        }
    }
}

function simple_type(value: any): Type {
    if (is_boolean(value)) {
        return Type.Boolean
    } else if (is_number(value)) {
        return Type.Integer
    } else if (is_string(value)) {
        return Type.String
    } else if (is_object(value)) {
        return Type.Object
    } else if (is_undefined(value)) {
        return Type.Undefined
    } else if (is_function(value)) {
        return Type.FunctionRef
    }

    throw Error("Unknown Type for: " + typeof(value))
}

// types of things

function is_boolean(value: any) {
    return typeof(value) === "boolean"
}


function is_number(value: any) {
    return typeof(value) === "number"
}


function is_string(value: any) {
    return typeof(value) === "string"
}

function is_object(value: any) {
    return typeof(value) === "object"
}

function is_undefined(value: any) {
    return typeof(value) === "undefined"
}

function is_function(value: any) {
    return typeof(value) === "function"
}
